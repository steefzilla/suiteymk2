#!/usr/bin/env bash

# Suitey - Cross-platform test runner
# This file was generated by build.sh - do not edit directly

# Version: 0.1.0
# Built: 2026-01-09 04:15:12 UTC
# Built on: Linux 6.8.0-90-generic

# Included from: src/environment.sh
#!/usr/bin/env bash

# Suitey Environment Validation Functions
# These functions validate that the development and runtime environment
# is properly configured for Suitey to operate correctly.

# Check if Bash version is 4.0 or higher
check_bash_version() {
    local bash_version
    bash_version=$(bash --version | head -n1 | grep -oE '[0-9]+\.[0-9]+' | head -n1)

    if [[ $(echo "$bash_version >= 4.0" | bc -l) -eq 1 ]]; then
        return 0
    else
        echo "Error: Bash version $bash_version is too old. Suitey requires Bash 4.0 or higher." >&2
        echo "Current version: $bash_version" >&2
        echo "Please upgrade Bash to version 4.0 or higher." >&2
        echo "On Ubuntu/Debian: sudo apt-get install bash" >&2
        echo "On macOS with Homebrew: brew install bash" >&2
        return 1
    fi
}

# Check if Docker is installed and accessible
check_docker_installed() {
    if command -v docker >/dev/null 2>&1; then
        return 0
    else
        echo "Error: Docker is not installed. Suitey requires Docker for containerized builds and test execution." >&2
        echo "Please install Docker:" >&2
        echo "  - Ubuntu/Debian: sudo apt-get install docker.io" >&2
        echo "  - CentOS/RHEL: sudo yum install docker" >&2
        echo "  - macOS: Download from https://www.docker.com/products/docker-desktop" >&2
        echo "  - Windows: Download from https://www.docker.com/products/docker-desktop" >&2
        return 1
    fi
}

# Check if Docker daemon is running
check_docker_daemon_running() {
    if docker info >/dev/null 2>&1; then
        return 0
    else
        echo "Error: Docker daemon is not running. Suitey requires a running Docker daemon." >&2
        echo "Please start Docker:" >&2
        echo "  - Linux: sudo systemctl start docker (or sudo service docker start)" >&2
        echo "  - macOS/Windows: Start Docker Desktop application" >&2
        echo "  - Or run: sudo dockerd (in a separate terminal)" >&2
        return 1
    fi
}

# Check if required directories exist
check_required_directories() {
    local dirs=("src" "tests/bats" "mod")
    local missing_dirs=()

    for dir in "${dirs[@]}"; do
        if [[ ! -d "$dir" ]]; then
            missing_dirs+=("$dir")
        fi
    done

    if [[ ${#missing_dirs[@]} -eq 0 ]]; then
        return 0
    else
        echo "Error: Required directories are missing: ${missing_dirs[*]}" >&2
        echo "Please create the missing directories:" >&2
        for dir in "${missing_dirs[@]}"; do
            echo "  mkdir -p $dir" >&2
        done
        return 1
    fi
}

# Check if /tmp directory is writable
check_tmp_writable() {
    if [[ -w "/tmp" ]]; then
        return 0
    else
        echo "Error: /tmp directory is not writable. Suitey requires write access to /tmp for temporary files." >&2
        echo "Please check /tmp permissions:" >&2
        echo "  ls -ld /tmp" >&2
        echo "If permissions are incorrect, you may need to:" >&2
        echo "  sudo chmod 1777 /tmp" >&2
        return 1
    fi
}

# Check if required test dependencies are available
check_test_dependencies() {
    local deps=("bats")
    local missing_deps=()

    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done

    # Check for bats-support and bats-assert libraries
    if [[ ! -f "tests/bats/unit/test_helper/bats-support/load.bash" ]]; then
        missing_deps+=("bats-support")
    fi

    if [[ ! -f "tests/bats/unit/test_helper/bats-assert/load.bash" ]]; then
        missing_deps+=("bats-assert")
    fi

    if [[ ${#missing_deps[@]} -eq 0 ]]; then
        return 0
    else
        echo "Error: Required test dependencies are missing: ${missing_deps[*]}" >&2
        echo "Please install the missing dependencies:" >&2

        for dep in "${missing_deps[@]}"; do
            case "$dep" in
                "bats")
                    echo "  - BATS testing framework:" >&2
                    echo "    Ubuntu/Debian: sudo apt-get install bats" >&2
                    echo "    macOS: brew install bats-core" >&2
                    echo "    Or download from: https://github.com/bats-core/bats-core" >&2
                    ;;
                "bats-support")
                    echo "  - bats-support library:" >&2
                    echo "    git clone https://github.com/bats-core/bats-support.git tests/bats/unit/test_helper/bats-support" >&2
                    ;;
                "bats-assert")
                    echo "  - bats-assert library:" >&2
                    echo "    git clone https://github.com/bats-core/bats-assert.git tests/bats/unit/test_helper/bats-assert" >&2
                    ;;
            esac
        done

        return 1
    fi
}

# Check if files can be created in /tmp directory
create_test_file_in_tmp() {
    local test_file="/tmp/suitey_test_file_$$"

    # Try to create a test file in /tmp
    if echo "test content" > "$test_file" 2>/dev/null; then
        # Clean up the test file
        rm -f "$test_file"
        return 0
    else
        echo "Error: Cannot create files in /tmp directory. Suitey requires write access to /tmp." >&2
        return 1
    fi
}

# Verify that filesystem isolation principle is maintained
verify_filesystem_isolation_principle() {
    # This function verifies that Suitey respects filesystem isolation
    # Suitey should only write to /tmp, not modify the project directory
    local project_dir
    project_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

    # Check that project directory exists and is accessible for reading
    if [[ -d "$project_dir" && -r "$project_dir" ]]; then
        # Project directory should be readable for Suitey to function
        # The isolation principle means Suitey won't write here during execution
        return 0
    else
        echo "Error: Project directory is not accessible. This may indicate permission issues." >&2
        return 1
    fi
}

# Check if temporary directories can be created in /tmp
create_test_directory_in_tmp() {
    local test_dir="/tmp/suitey_test_dir_$$"

    # Try to create a test directory in /tmp
    if mkdir "$test_dir" 2>/dev/null; then
        # Clean up the test directory
        rmdir "$test_dir"
        return 0
    else
        echo "Error: Cannot create directories in /tmp. Suitey requires write access to /tmp for temporary directories." >&2
        return 1
    fi
}

# Verify that environment checks respect filesystem isolation principle
verify_environment_filesystem_isolation() {
    # This function verifies that all environment validation functions
    # only access /tmp and don't modify the project directory
    local project_dir
    project_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

    # Use a lighter approach - check for temporary files created outside /tmp
    # instead of full checksum comparison
    local temp_files_before
    temp_files_before=$(find "$project_dir" -name "suitey_*" -type f 2>/dev/null | wc -l)

    # Run all environment validation functions
    check_bash_version >/dev/null 2>&1
    check_docker_installed >/dev/null 2>&1
    check_docker_daemon_running >/dev/null 2>&1
    check_required_directories >/dev/null 2>&1
    check_tmp_writable >/dev/null 2>&1
    check_test_dependencies >/dev/null 2>&1

    local temp_files_after
    temp_files_after=$(find "$project_dir" -name "suitey_*" -type f 2>/dev/null | wc -l)

    # Verify that no suitey temporary files were created in project directory
    if [[ "$temp_files_before" -eq "$temp_files_after" ]]; then
        return 0
    else
        echo "Error: Environment validation functions created files outside /tmp. This violates filesystem isolation." >&2
        return 1
    fi
}
# End of: src/environment.sh

# Included from: src/data_access.sh
#!/usr/bin/env bash

# Suitey Data Access Functions
# Pure Bash data manipulation utilities for the flat data format
# No external dependencies

# Extract a value from data using a key path
# Usage: data_get <data> <key>
# Returns: Extracted value as string, or empty string if not found
# Exit code: 0 on success, 1 on error (empty inputs)
data_get() {
    local data="$1"
    local key="$2"

    # Validate inputs
    if [[ -z "$data" ]] || [[ -z "$key" ]]; then
        return 1
    fi

    # Search for the first occurrence of key= in the data
    local line
    line=$(echo "$data" | grep -m 1 "^${key}=" || true)

    # If not found, return empty string
    if [[ -z "$line" ]]; then
        echo ""
        return 0
    fi

    # Extract value after the = sign
    local value="${line#${key}=}"

    # Remove surrounding quotes if present (both double and single quotes)
    # This handles values like "quoted value" or 'single quoted'
    if [[ "$value" =~ ^\".*\"$ ]]; then
        # Remove double quotes
        value="${value#\"}"
        value="${value%\"}"
    elif [[ "$value" =~ ^\'.*\'$ ]]; then
        # Remove single quotes
        value="${value#\'}"
        value="${value%\'}"
    fi

    # Output the value
    echo "$value"
    return 0
}

# Extract an array element from data by index
# Usage: data_get_array <data> <array_name> <index>
# Returns: Array element value, or empty if not found
# Exit code: 0 on success, 1 on error (invalid inputs)
# Behavior: Constructs key as ${array_name}_${index} and calls data_get()
data_get_array() {
    local data="$1"
    local array_name="$2"
    local index="$3"

    # Validate inputs
    if [[ -z "$data" ]] || [[ -z "$array_name" ]] || [[ -z "$index" ]]; then
        return 1
    fi

    # Validate index is numeric (0-based, non-negative integer)
    if ! [[ "$index" =~ ^[0-9]+$ ]]; then
        return 1
    fi

    # Construct key as ${array_name}_${index} (e.g., "test_files_0")
    local key="${array_name}_${index}"

    # Call data_get() with the constructed key
    data_get "$data" "$key"
    return $?
}

# Get the count of elements in an array
# Usage: data_array_count <data> <array_name>
# Returns: Array count as integer string, or "0" if not found/invalid
# Exit code: 0 on success, 1 if inputs are empty
# Behavior: Looks for ${array_name}_count key and validates it's numeric
data_array_count() {
    local data="$1"
    local array_name="$2"

    # Validate inputs
    if [[ -z "$data" ]] || [[ -z "$array_name" ]]; then
        return 1
    fi

    # Look for ${array_name}_count key (e.g., "test_files_count")
    local count_key="${array_name}_count"
    local count_value
    count_value=$(data_get "$data" "$count_key")

    # If not found, return "0"
    if [[ -z "$count_value" ]]; then
        echo "0"
        return 0
    fi

    # Validate that the value is numeric (non-negative integer)
    if ! [[ "$count_value" =~ ^[0-9]+$ ]]; then
        echo "0"
        return 0
    fi

    # Return the count
    echo "$count_value"
    return 0
}

# Extract all elements from an array
# Usage: data_get_array_all <data> <array_name>
# Returns: Array elements, one per line (stdout), or empty if array doesn't exist
# Exit code: 0 on success
# Behavior: Gets array count, then iterates from 0 to count-1, calling data_get_array() for each index
data_get_array_all() {
    local data="$1"
    local array_name="$2"

    # Validate inputs (but don't fail - return empty if invalid)
    if [[ -z "$data" ]] || [[ -z "$array_name" ]]; then
        return 0
    fi

    # Get array count using data_array_count()
    local count
    count=$(data_array_count "$data" "$array_name")

    # If count is 0, return empty (no elements to return)
    if [[ "$count" == "0" ]]; then
        return 0
    fi

    # Iterate from 0 to count-1, retrieving each element
    local i=0
    while [[ $i -lt $count ]]; do
        # Get array element at index i using data_get_array()
        local element
        element=$(data_get_array "$data" "$array_name" "$i")
        echo "$element"
        i=$((i + 1))
    done

    return 0
}

# Set a value in data, creating new data with updated value
# Usage: data_set <data> <key> <value>
# Returns: Updated data string (stdout)
# Exit code: 0 on success, 1 if key is empty
# Behavior: Removes existing key if present, escapes value if needed, appends new key-value pair
data_set() {
    local data="$1"
    local key="$2"
    local value="$3"

    # Validate key is not empty
    if [[ -z "$key" ]]; then
        return 1
    fi

    # Remove existing key if present (including multi-line heredoc blocks)
    # Remove lines matching "^${key}="
    local filtered_data
    filtered_data=$(echo "$data" | grep -v "^${key}=" || true)
    
    # Remove heredoc blocks for this key (lines between "${key}<<EOF" and "EOF")
    local cleaned_data=""
    local in_heredoc=false
    local heredoc_start="${key}<<EOF"
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Check if line starts with heredoc marker
        local line_prefix="${line%%<<*}"
        if [[ "$line_prefix" == "$key" ]] && [[ "$line" == *"<<"* ]]; then
            in_heredoc=true
            continue
        fi
        
        # Check if we're ending a heredoc block
        if [[ "$in_heredoc" == true ]] && [[ "$line" == "EOF" ]]; then
            in_heredoc=false
            continue
        fi
        
        # Only include lines that are not part of a heredoc block
        if [[ "$in_heredoc" == false ]]; then
            if [[ -n "$cleaned_data" ]]; then
                cleaned_data="${cleaned_data}"$'\n'"${line}"
            else
                cleaned_data="${line}"
            fi
        fi
    done <<< "$filtered_data"
    
    # If cleaned_data is empty, use filtered_data
    if [[ -z "$cleaned_data" ]]; then
        cleaned_data="$filtered_data"
    fi

    # Escape value if it contains special characters (spaces, $, `, ", \)
    local escaped_value="$value"
    # Check if value contains special characters that need escaping
    if [[ "$value" =~ [[:space:]] ]] || [[ "$value" =~ \$ ]] || [[ "$value" =~ \` ]] || [[ "$value" =~ \" ]] || [[ "$value" =~ \\ ]]; then
        # Wrap in quotes and escape internal quotes and backslashes
        escaped_value=$(echo "$value" | sed 's/\\/\\\\/g; s/"/\\"/g')
        escaped_value="\"${escaped_value}\""
    fi

    # Append new key-value pair to data
    local result
    if [[ -n "$cleaned_data" ]]; then
        result="${cleaned_data}"$'\n'"${key}=${escaped_value}"
    else
        result="${key}=${escaped_value}"
    fi

    # Output the updated data
    echo "$result"
    return 0
}

# Append a value to an array
# Usage: data_array_append <data> <array_name> <value>
# Returns: Updated data string with new array element
# Exit code: 0 on success
# Behavior: Gets current count, sets new element at index count, updates count to count+1
data_array_append() {
    local data="$1"
    local array_name="$2"
    local value="$3"

    # Get current array count
    local count
    count=$(data_array_count "$data" "$array_name")
    
    # If count failed or returned error, default to 0
    if [[ $? -ne 0 ]] || [[ -z "$count" ]]; then
        count=0
    fi

    # Set new element at index count using data_set()
    data=$(data_set "$data" "${array_name}_${count}" "$value")

    # Update count to count + 1 using data_set()
    local new_count=$((count + 1))
    data=$(data_set "$data" "${array_name}_count" "$new_count")

    # Return updated data string
    echo "$data"
    return 0
}

# Set an entire array, replacing any existing array entries
# Usage: data_set_array <data> <array_name> <value1> [value2] [value3] ...
# Returns: Updated data string
# Exit code: 0 on success
# Behavior: Removes all existing array entries, adds new entries at sequential indices
data_set_array() {
    local data="$1"
    local array_name="$2"
    shift 2  # Remove first two arguments, leaving only values

    # Get current count to know how many entries to remove
    local old_count
    old_count=$(data_array_count "$data" "$array_name")
    
    # Remove all existing array entries (${array_name}_N= and ${array_name}_count=)
    # Remove entries from 0 to old_count-1
    if [[ "$old_count" -gt 0 ]]; then
        local i=0
        while [[ $i -lt $old_count ]]; do
            # Remove the array element line
            data=$(echo "$data" | grep -v "^${array_name}_${i}=" || true)
            i=$((i + 1))
        done
    fi
    
    # Remove the count line
    data=$(echo "$data" | grep -v "^${array_name}_count=" || true)
    
    # Remove empty lines that might have been created
    data=$(echo "$data" | grep -v "^$" || true)
    
    # If data is now empty or only whitespace, reset it
    if [[ -z "${data// }" ]]; then
        data=""
    fi

    # Add new entries for each value at sequential indices
    local index=0
    local values=("$@")
    
    for value in "${values[@]}"; do
        data=$(data_set "$data" "${array_name}_${index}" "$value")
        index=$((index + 1))
    done

    # Set count to number of values added
    data=$(data_set "$data" "${array_name}_count" "$index")

    # Return updated data string
    echo "$data"
    return 0
}

# Set a multi-line value using heredoc syntax
# Usage: data_set_multiline <data> <key> <value>
# Returns: Updated data string with heredoc syntax
# Exit code: 0 on success
# Behavior: Removes existing heredoc block or regular key=value entry, appends new heredoc block
data_set_multiline() {
    local data="$1"
    local key="$2"
    local value="$3"

    # Validate key is not empty
    if [[ -z "$key" ]]; then
        return 1
    fi

    # Remove existing heredoc block if present (lines between `${key}<<EOF` and `EOF`)
    # Also remove regular key=value entry for this key
    local cleaned_data=""
    local in_heredoc=false
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Check if line starts with heredoc marker for this key (e.g., "key<<EOF")
        if [[ "${line%%<<*}" == "$key" ]] && [[ "$line" == *"<<"* ]]; then
            in_heredoc=true
            continue
        fi
        
        # Check if we're ending a heredoc block
        if [[ "$in_heredoc" == true ]] && [[ "$line" == "EOF" ]]; then
            in_heredoc=false
            continue
        fi
        
        # Skip lines that are part of a heredoc block
        if [[ "$in_heredoc" == true ]]; then
            continue
        fi
        
        # Skip regular key=value entry for this key
        if [[ "$line" =~ ^${key}= ]]; then
            continue
        fi
        
        # Include all other lines
        if [[ -n "$cleaned_data" ]]; then
            cleaned_data="${cleaned_data}"$'\n'"${line}"
        else
            cleaned_data="${line}"
        fi
    done <<< "$data"
    
    # If cleaned_data is empty, reset it
    if [[ -z "${cleaned_data// }" ]]; then
        cleaned_data=""
    fi

    # Append new heredoc block: `${key}<<EOF`, value lines, `EOF`
    local result
    if [[ -n "$cleaned_data" ]]; then
        result="${cleaned_data}"$'\n'"${key}<<EOF"
    else
        result="${key}<<EOF"
    fi
    
    # Add value lines if not empty
    if [[ -n "$value" ]]; then
        result="${result}"$'\n'"${value}"
    fi
    
    # Add EOF marker
    result="${result}"$'\n'"EOF"

    # Output the updated data
    echo "$result"
    return 0
}

# Get a multi-line value, handling heredoc syntax
# Usage: data_get_multiline <data> <key>
# Returns: Multi-line value (without heredoc markers), or single-line value
# Exit code: 0 on success, 1 on error (invalid inputs)
# Behavior: Checks if key uses heredoc syntax, extracts content between markers or calls data_get()
data_get_multiline() {
    local data="$1"
    local key="$2"

    # Validate inputs
    if [[ -z "$data" ]] || [[ -z "$key" ]]; then
        return 1
    fi

    # Check if key uses heredoc syntax (`${key}<<EOF`)
    local in_heredoc=false
    local heredoc_content=""
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Check if line starts with heredoc marker for this key (e.g., "key<<EOF")
        if [[ "${line%%<<*}" == "$key" ]] && [[ "$line" == *"<<"* ]]; then
            in_heredoc=true
            continue
        fi
        
        # Check if we're ending a heredoc block
        if [[ "$in_heredoc" == true ]] && [[ "$line" == "EOF" ]]; then
            # Found complete heredoc block, return content
            echo "$heredoc_content"
            return 0
        fi
        
        # Collect content between heredoc markers
        if [[ "$in_heredoc" == true ]]; then
            if [[ -n "$heredoc_content" ]]; then
                heredoc_content="${heredoc_content}"$'\n'"${line}"
            else
                heredoc_content="${line}"
            fi
        fi
    done <<< "$data"
    
    # If we were in a heredoc but didn't find EOF, return what we collected
    if [[ "$in_heredoc" == true ]]; then
        echo "$heredoc_content"
        return 0
    fi
    
    # If not heredoc, call data_get() for regular single-line value
    data_get "$data" "$key"
    return $?
}

# Validate that a string conforms to the data format specification
# Usage: data_validate <data>
# Exit code: 0 if valid data format, 1 if invalid
# Behavior: Validates each line against allowed patterns (key=value, comments, sections, heredoc)
data_validate() {
    local data="$1"

    # Empty input is considered valid
    if [[ -z "$data" ]]; then
        return 0
    fi

    # Validate each line
    local in_heredoc=false
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines
        if [[ -z "${line// }" ]]; then
            continue
        fi

        # Allow comment lines (starting with #)
        if [[ "$line" =~ ^# ]]; then
            continue
        fi

        # Allow section headers ([section_name])
        if [[ "$line" =~ ^\[.*\]$ ]]; then
            continue
        fi

        # Allow heredoc start markers (key<<EOF)
        # Check if line contains << and doesn't start with =
        if [[ "$line" == *"<<"* ]] && [[ "$line" != "="* ]]; then
            in_heredoc=true
            continue
        fi

        # Allow heredoc end markers (EOF)
        if [[ "$line" == "EOF" ]]; then
            in_heredoc=false
            continue
        fi

        # Skip validation for lines inside heredoc blocks
        if [[ "$in_heredoc" == true ]]; then
            continue
        fi

        # Require other lines to match key=value pattern
        if [[ ! "$line" =~ ^[^=]+= ]]; then
            return 1
        fi
    done <<< "$data"

    # All lines are valid
    return 0
}

# Check if a key exists in data
# Usage: data_has_key <data> <key>
# Exit code: 0 if key exists, 1 if not found or invalid inputs
# Behavior: Searches for lines starting with ${key}=
data_has_key() {
    local data="$1"
    local key="$2"

    # Validate inputs
    if [[ -z "$data" ]] || [[ -z "$key" ]]; then
        return 1
    fi

    # Search for lines starting with ${key}=
    # Use grep to find exact match (key= at start of line)
    if echo "$data" | grep -q "^${key}="; then
        return 0
    fi

    # Key not found
    return 1
}

# End of: src/data_access.sh

# Included from: src/mod_registry.sh
#!/usr/bin/env bash

# Suitey Modules Registry
# Centralized registry for Suitey Modules with registration, lookup, and lifecycle management
# No external dependencies

# Registry storage (using associative arrays)
declare -A MODULE_REGISTRY
declare -A MODULE_METADATA

# Required interface methods that all modules must implement
readonly REQUIRED_METHODS=(
    "detect"
    "check_binaries"
    "discover_test_suites"
    "detect_build_requirements"
    "get_build_steps"
    "execute_test_suite"
    "parse_test_results"
    "get_metadata"
)

# Reset the registry (for testing)
reset_registry() {
    # Clear arrays (use -g to ensure we're modifying global arrays)
    unset MODULE_REGISTRY MODULE_METADATA
    declare -gA MODULE_REGISTRY
    declare -gA MODULE_METADATA
}

# Validate that a module implements all required interface methods
# Usage: validate_module_interface
# Exit code: 0 if valid, 1 if invalid
# Note: This should be called after sourcing a module script
validate_module_interface() {
    # Check if all required methods exist as functions
    for method in "${REQUIRED_METHODS[@]}"; do
        # Check if method exists as a function
        if ! declare -f "$method" >/dev/null 2>&1; then
            return 1
        fi
    done

    return 0
}

# Validate module metadata structure
# Usage: validate_module_metadata <metadata_data>
# Exit code: 0 if valid, 1 if invalid
validate_module_metadata() {
    local metadata="$1"

    # Basic validation: check that metadata is not empty
    if [[ -z "$metadata" ]]; then
        return 1
    fi

    # Check for required fields (can be lenient for now)
    # At minimum, should have language field (for backward compatibility)
    # module_type is optional but recommended
    if ! echo "$metadata" | grep -q "^language="; then
        return 1
    fi

    return 0
}

# Validate module method signature (parameter count)
# Usage: validate_module_method_signature <method_name> <expected_param_count>
# Exit code: 0 if valid, 1 if invalid
# Note: In Bash, we can't easily check parameter count at runtime without calling the function
# This is a placeholder for signature validation - actual validation would require static analysis
validate_module_method_signature() {
    local method_name="$1"
    local expected_param_count="$2"

    # Check if method exists
    if ! declare -f "$method_name" >/dev/null 2>&1; then
        return 1
    fi

    # In Bash, we can't easily check parameter count without parsing the function definition
    # For now, we just verify the method exists
    # Full signature validation would require parsing the function definition
    return 0
}

# Validate module return format (flat data format)
# Usage: validate_module_return_format <return_value>
# Exit code: 0 if valid flat data format, 1 if invalid
validate_module_return_format() {
    local return_value="$1"

    # Empty return is valid (methods may return empty when not applicable)
    if [[ -z "$return_value" ]]; then
        return 0
    fi

    # Check if return value contains key=value pairs (flat data format)
    # Should not contain JSON-like structures
    if echo "$return_value" | grep -q '[{}]'; then
        # Contains braces, likely JSON - invalid
        return 1
    fi

    # Check if it contains at least one key=value pair
    if ! echo "$return_value" | grep -q "^[^=]*="; then
        # No key=value pairs found - may be invalid
        # But allow empty or single-line values
        if [[ -n "${return_value// }" ]]; then
            # Non-empty but no = sign - might be invalid
            # For now, be lenient and allow it
            return 0
        fi
    fi

    return 0
}

# Perform complete interface validation for a module
# Usage: validate_module_interface_complete <identifier>
# Exit code: 0 if valid, 1 if invalid
validate_module_interface_complete() {
    local identifier="$1"

    if [[ -z "$identifier" ]]; then
        echo "Error: Module identifier cannot be empty" >&2
        return 1
    fi

    # Check if module is registered
    if [[ -z "${MODULE_REGISTRY[$identifier]}" ]]; then
        echo "Error: Module '$identifier' is not registered" >&2
        return 1
    fi

    # Validate all required methods exist
    if ! validate_module_interface; then
        echo "Error: Module '$identifier' does not implement all required methods" >&2
        return 1
    fi

    # Validate each method's return format (sample validation)
    # For detect() method
    if declare -f "detect" >/dev/null 2>&1; then
        local sample_result
        sample_result=$(detect "/tmp" 2>/dev/null || echo "")
        if ! validate_module_return_format "$sample_result"; then
            echo "Error: Module '$identifier' method 'detect()' returns invalid format" >&2
            return 1
        fi
    fi

    # Validate get_metadata() return format
    if declare -f "get_metadata" >/dev/null 2>&1; then
        local metadata
        metadata=$(get_metadata 2>/dev/null || echo "")
        if ! validate_module_return_format "$metadata"; then
            echo "Error: Module '$identifier' method 'get_metadata()' returns invalid format" >&2
            return 1
        fi
    fi

    return 0
}

# Register a Suitey module
# Usage: register_module <identifier> <module_name>
# Exit code: 0 on success, 1 on error
# Note: Module should be sourced before calling this function
register_module() {
    local identifier="$1"
    local module_name="$2"

    # Validate identifier is not empty
    if [[ -z "$identifier" ]]; then
        echo "Error: Module identifier cannot be empty" >&2
        return 1
    fi

    # Check if module is already registered
    if [[ -n "${MODULE_REGISTRY[$identifier]}" ]]; then
        echo "Error: Module with identifier '$identifier' is already registered" >&2
        return 1
    fi

    # Validate module interface (check if required methods exist as functions)
    # Modules are sourced before registration, so functions should be available
    local interface_valid=true
    for method in "${REQUIRED_METHODS[@]}"; do
        # Check if method exists as a function
        if ! declare -f "$method" >/dev/null 2>&1; then
            echo "Error: Module '$identifier' is missing required method '$method'" >&2
            interface_valid=false
        fi
    done

    if [[ "$interface_valid" == false ]]; then
        return 1
    fi

    # Get module metadata
    local metadata=""
    if declare -f "get_metadata" >/dev/null 2>&1; then
        metadata=$(get_metadata)
    else
        echo "Error: Module '$identifier' does not provide get_metadata() method" >&2
        return 1
    fi

    # Validate metadata
    if ! validate_module_metadata "$metadata"; then
        echo "Error: Module '$identifier' has invalid metadata" >&2
        return 1
    fi

    # Register the module
    MODULE_REGISTRY[$identifier]="$module_name"
    MODULE_METADATA[$identifier]="$metadata"

    return 0
}

# Get a module by identifier
# Usage: get_module <identifier>
# Exit code: 0 on success, 1 if not found
get_module() {
    local identifier="$1"

    if [[ -z "$identifier" ]]; then
        echo "Error: Module identifier cannot be empty" >&2
        return 1
    fi

    if [[ -z "${MODULE_REGISTRY[$identifier]}" ]]; then
        echo "Error: Module '$identifier' not found" >&2
        return 1
    fi

    echo "${MODULE_REGISTRY[$identifier]}"
    return 0
}

# Get module metadata by identifier
# Usage: get_module_metadata <identifier>
# Exit code: 0 on success, 1 if not found
get_module_metadata() {
    local identifier="$1"

    if [[ -z "$identifier" ]]; then
        echo "Error: Module identifier cannot be empty" >&2
        return 1
    fi

    if [[ -z "${MODULE_METADATA[$identifier]}" ]]; then
        echo "Error: Module '$identifier' not found" >&2
        return 1
    fi

    echo "${MODULE_METADATA[$identifier]}"
    return 0
}

# Get all registered module identifiers
# Usage: get_all_modules
# Returns: List of module identifiers, one per line
get_all_modules() {
    # Ensure arrays are initialized
    if [[ -z "${MODULE_REGISTRY[*]}" ]]; then
        return 0
    fi

    local identifier
    for identifier in "${!MODULE_REGISTRY[@]}"; do
        echo "$identifier"
    done
}

# Get modules by capability
# Usage: get_modules_by_capability <capability>
# Returns: List of module identifiers that have the specified capability, one per line
get_modules_by_capability() {
    local capability="$1"

    if [[ -z "$capability" ]]; then
        return 0
    fi

    local identifier
    local modules=""
    for identifier in "${!MODULE_REGISTRY[@]}"; do
        # Get module metadata
        local metadata="${MODULE_METADATA[$identifier]}"
        
        if [[ -z "$metadata" ]]; then
            continue
        fi

        # Check if metadata contains the capability
        # Capabilities are stored as capabilities_0=..., capabilities_1=..., etc.
        # Use grep to check for capability in metadata
        if echo "$metadata" | grep -q "^capabilities_[0-9]*=${capability}$"; then
            if [[ -z "$modules" ]]; then
                modules="$identifier"
            else
                modules="${modules}"$'\n'"${identifier}"
            fi
        fi
    done

    if [[ -n "$modules" ]]; then
        echo "$modules"
    fi

    return 0
}

# Get all registered capabilities
# Usage: get_capabilities
# Returns: List of all capabilities from all modules, one per line (deduplicated)
get_capabilities() {
    local identifier
    local all_capabilities=""
    
    for identifier in "${!MODULE_REGISTRY[@]}"; do
        # Get module metadata
        local metadata="${MODULE_METADATA[$identifier]}"
        
        if [[ -z "$metadata" ]]; then
            continue
        fi

        # Extract capabilities from metadata using grep
        # Capabilities are stored as capabilities_0=..., capabilities_1=..., etc.
        local capabilities
        capabilities=$(echo "$metadata" | grep "^capabilities_[0-9]*=" | sed 's/^capabilities_[0-9]*=//')
        
        # Add capabilities to the list
        if [[ -n "$capabilities" ]]; then
            if [[ -z "$all_capabilities" ]]; then
                all_capabilities="$capabilities"
            else
                all_capabilities="${all_capabilities}"$'\n'"${capabilities}"
            fi
        fi
    done

    # Deduplicate and sort capabilities
    if [[ -n "$all_capabilities" ]]; then
        echo "$all_capabilities" | sort -u
    fi

    return 0
}

# Get modules by type
# Usage: get_modules_by_type <module_type>
# Returns: List of module identifiers of the specified type, one per line
# Module types: language, framework, project
get_modules_by_type() {
    local module_type="$1"
    local identifier
    local modules=""
    
    if [[ -z "$module_type" ]]; then
        return 0
    fi
    
    for identifier in "${!MODULE_REGISTRY[@]}"; do
        # Get module metadata
        local metadata="${MODULE_METADATA[$identifier]}"
        
        if [[ -z "$metadata" ]]; then
            continue
        fi

        # Extract module_type from metadata
        local metadata_type
        metadata_type=$(echo "$metadata" | grep "^module_type=" | cut -d'=' -f2 || echo "")
        
        # Match module type (case-sensitive)
        if [[ "$metadata_type" == "$module_type" ]]; then
            if [[ -z "$modules" ]]; then
                modules="$identifier"
            else
                modules="${modules}"$'\n'"${identifier}"
            fi
        fi
    done

    if [[ -n "$modules" ]]; then
        echo "$modules"
    fi

    return 0
}

# Get language modules (convenience method)
# Usage: get_language_modules
# Returns: List of language module identifiers, one per line
get_language_modules() {
    get_modules_by_type "language"
    return 0
}

# Get framework modules (convenience method)
# Usage: get_framework_modules
# Returns: List of framework module identifiers, one per line
get_framework_modules() {
    get_modules_by_type "framework"
    return 0
}

# Get project modules (convenience method)
# Usage: get_project_modules
# Returns: List of project module identifiers, one per line
get_project_modules() {
    get_modules_by_type "project"
    return 0
}


# End of: src/mod_registry.sh

# Included from: src/platform_detector.sh
#!/usr/bin/env bash

# Suitey Platform Detector
# Identifies which programming languages/frameworks are present in a project
# Uses Suitey Modules Registry to coordinate language-specific detection
# No external dependencies

# Source data access functions if available (for parsing flat data)
if [[ -f "src/data_access.sh" ]]; then
    source "src/data_access.sh" 2>/dev/null || true
fi

# Detect platforms in a project
# Usage: detect_platforms <project_root>
# Returns: Detection results as flat data
# Behavior: Uses Modules Registry to get all modules, calls each module's detect() method, aggregates results
detect_platforms() {
    local project_root="$1"

    # Validate input
    if [[ -z "$project_root" ]]; then
        echo "platforms_count=0"
        return 0
    fi

    # Get all registered modules
    local modules
    modules=$(get_all_modules 2>/dev/null || echo "")

    if [[ -z "$modules" ]]; then
        echo "platforms_count=0"
        return 0
    fi

    # Track detected platforms
    local platforms_count=0
    local platform_index=0
    local results=""

    # Process each module
    while IFS= read -r module_id || [[ -n "$module_id" ]]; do
        # Get module name
        local module_name
        module_name=$(get_module "$module_id" 2>/dev/null || echo "")

        if [[ -z "$module_name" ]]; then
            continue
        fi

        # Determine module file path based on module_id
        # Module IDs follow pattern: {language}-module or {framework}-module
        # Module files are at: mod/languages/{language}/mod.sh or mod/frameworks/{framework}/mod.sh
        local module_file=""

        # Try language modules first
        if [[ "$module_id" == *"-module" ]]; then
            local language="${module_id%-module}"
            module_file="mod/languages/${language}/mod.sh"
        fi

        # If not a language module, try framework modules
        if [[ ! -f "$module_file" ]] && [[ "$module_id" == *"-module" ]]; then
            local framework="${module_id%-module}"
            module_file="mod/frameworks/${framework}/mod.sh"
        fi

        # If not found, skip
        if [[ ! -f "$module_file" ]]; then
            continue
        fi

        # Clean up any existing module functions to avoid conflicts
        for method in detect check_binaries discover_test_suites detect_build_requirements get_build_steps execute_test_suite parse_test_results get_metadata; do
            unset -f "$method" 2>/dev/null || true
        done

        # Source the module
        source "$module_file" 2>/dev/null || continue

        # Call module's detect() method
        local detection_result
        detection_result=$(detect "$project_root" 2>/dev/null || echo "")

        if [[ -z "$detection_result" ]]; then
            continue
        fi

        # Check if platform was detected
        local detected
        if declare -f data_get >/dev/null 2>&1; then
            detected=$(data_get "$detection_result" "detected" || echo "false")
        else
            detected=$(echo "$detection_result" | grep "^detected=" | cut -d'=' -f2 || echo "false")
        fi

        if [[ "$detected" == "true" ]]; then
            # Platform detected - add to results
            # Extract language and framework from detection result
            local language
            local framework
            local confidence

            if declare -f data_get >/dev/null 2>&1; then
                language=$(data_get "$detection_result" "language" || echo "")
                framework=$(data_get "$detection_result" "frameworks_0" || echo "")
                confidence=$(data_get "$detection_result" "confidence" || echo "low")
            else
                language=$(echo "$detection_result" | grep "^language=" | cut -d'=' -f2 || echo "")
                framework=$(echo "$detection_result" | grep "^frameworks_0=" | cut -d'=' -f2 || echo "")
                confidence=$(echo "$detection_result" | grep "^confidence=" | cut -d'=' -f2 || echo "low")
            fi

            # Add platform to results
            if [[ -n "$results" ]]; then
                results="${results}"$'\n'"platforms_${platform_index}_language=${language}"
            else
                results="platforms_${platform_index}_language=${language}"
            fi

            if [[ -n "$framework" ]]; then
                results="${results}"$'\n'"platforms_${platform_index}_framework=${framework}"
            fi

            results="${results}"$'\n'"platforms_${platform_index}_confidence=${confidence}"
            results="${results}"$'\n'"platforms_${platform_index}_module_id=${module_id}"

            # Add detection indicators
            local indicators_count
            if declare -f data_array_count >/dev/null 2>&1; then
                indicators_count=$(data_array_count "$detection_result" "indicators" || echo "0")
            else
                indicators_count=$(echo "$detection_result" | grep "^indicators_count=" | cut -d'=' -f2 || echo "0")
            fi
            results="${results}"$'\n'"platforms_${platform_index}_indicators_count=${indicators_count}"

            # Add individual indicators
            local i=0
            while [[ $i -lt "$indicators_count" ]]; do
                local indicator
                if declare -f data_get_array >/dev/null 2>&1; then
                    indicator=$(data_get_array "$detection_result" "indicators" "$i" || echo "")
                else
                    indicator=$(echo "$detection_result" | grep "^indicators_${i}=" | cut -d'=' -f2 || echo "")
                fi
                if [[ -n "$indicator" ]]; then
                    results="${results}"$'\n'"platforms_${platform_index}_indicators_${i}=${indicator}"
                fi
                i=$((i + 1))
            done

            platforms_count=$((platforms_count + 1))
            platform_index=$((platform_index + 1))
        fi
    done <<< "$modules"

    # Output results
    echo "platforms_count=${platforms_count}"
    if [[ -n "$results" ]]; then
        echo "$results"
    fi

    return 0
}

# End of: src/platform_detector.sh

# Included from: src/test_source_4000308.sh
# Test source file
test_function() {
    echo "test function"
}

# End of: src/test_source_4000308.sh

# Included from: mod/frameworks/bats/mod.sh
#!/usr/bin/env bash

# Suitey BATS Framework Module
# Handles BATS framework for Bash language
# Provides framework-specific test discovery, execution, and parsing for BATS projects
#
# This module works in conjunction with the Bash language module:
# - Language module (mod/languages/bash/mod.sh) detects Bash language presence
# - Framework module (this module) handles BATS-specific operations
# - Framework module has higher priority than language module for framework-specific operations

# Detect if BATS project is present (framework-level detection)
# Usage: detect <project_root>
# Returns: Detection result as flat data
# Behavior: Checks for .bats files (framework-specific indicator)
detect() {
    local project_root="$1"

    # Validate input
    if [[ -z "$project_root" ]] || [[ ! -d "$project_root" ]]; then
        echo "detected=false"
        echo "confidence=low"
        echo "indicators_count=0"
        echo "language=bash"
        echo "frameworks_0=bats"
        return 0
    fi

    # Check for .bats files (primary BATS indicator)
    # Look in common test directories: tests/bats/, test/bats/, tests/, test/
    local bats_files
    bats_files=$(find "$project_root" -maxdepth 3 -name "*.bats" -type f 2>/dev/null | head -1)
    if [[ -n "$bats_files" ]]; then
        echo "detected=true"
        echo "confidence=high"
        echo "indicators_0=bats_test_files"
        echo "indicators_count=1"
        echo "language=bash"
        echo "frameworks_0=bats"
        return 0
    fi

    # Check for BATS test directory structure (secondary indicator)
    if [[ -d "$project_root/tests/bats" ]] || [[ -d "$project_root/test/bats" ]]; then
        echo "detected=true"
        echo "confidence=medium"
        echo "indicators_0=bats_test_directory"
        echo "indicators_count=1"
        echo "language=bash"
        echo "frameworks_0=bats"
        return 0
    fi

    # Not detected
    echo "detected=false"
    echo "confidence=low"
    echo "indicators_count=0"
    echo "language=bash"
    echo "frameworks_0=bats"
    return 0
}

# Check if required binaries are available
# Usage: check_binaries <project_root>
# Returns: Binary status as flat data
# Behavior: Checks for bats binary in PATH and reports version if available
check_binaries() {
    local project_root="$1"

    # Check for bats binary in PATH
    if command -v bats >/dev/null 2>&1; then
        local bats_version
        bats_version=$(bats --version 2>/dev/null | head -1 || echo "unknown")
        # Remove "bats " prefix if present
        bats_version="${bats_version#bats }"
        echo "available=true"
        echo "binaries_0=bats"
        echo "binaries_count=1"
        echo "versions_bats=$bats_version"
        echo "container_check=false"
    else
        echo "available=false"
        echo "binaries_0=bats"
        echo "binaries_count=1"
        echo "container_check=false"
    fi

    return 0
}

# Discover test suites in the project using BATS-specific patterns
# Usage: discover_test_suites <project_root> <framework_metadata>
# Returns: Test suites as flat data
# Behavior: Finds .bats files in common test directories (tests/bats/, test/bats/, etc.)
discover_test_suites() {
    local project_root="$1"
    local framework_metadata="$2"

    # Validate input
    if [[ -z "$project_root" ]] || [[ ! -d "$project_root" ]]; then
        echo "suites_count=0"
        return 0
    fi

    local suites_count=0
    local suite_index=0
    local results=""

    # Discover .bats files in common test directories
    # BATS tests are typically organized in tests/bats/ or test/bats/ directories
    local test_dirs=("$project_root/tests/bats" "$project_root/test/bats" "$project_root/tests" "$project_root/test")
    
    for test_dir in "${test_dirs[@]}"; do
        if [[ -d "$test_dir" ]]; then
            local bats_files
            bats_files=$(find "$test_dir" -name "*.bats" -type f 2>/dev/null)
            
            if [[ -n "$bats_files" ]]; then
                local file_count
                file_count=$(echo "$bats_files" | wc -l)
                
                if [[ $file_count -gt 0 ]]; then
                    # Create a suite for this directory
                    local suite_name
                    suite_name=$(basename "$test_dir")
                    
                    if [[ -z "$results" ]]; then
                        results="suites_${suite_index}_name=${suite_name}"
                    else
                        results="${results}"$'\n'"suites_${suite_index}_name=${suite_name}"
                    fi
                    results="${results}"$'\n'"suites_${suite_index}_framework=bats"
                    results="${results}"$'\n'"suites_${suite_index}_test_files_count=${file_count}"
                    
                    suites_count=$((suites_count + 1))
                    suite_index=$((suite_index + 1))
                    
                    # Only process first matching directory to avoid duplicates
                    break
                fi
            fi
        fi
    done

    # If no test directories found, search for .bats files anywhere
    if [[ $suites_count -eq 0 ]]; then
        local bats_files
        bats_files=$(find "$project_root" -maxdepth 3 -name "*.bats" -type f 2>/dev/null)
        
        if [[ -n "$bats_files" ]]; then
            local file_count
            file_count=$(echo "$bats_files" | wc -l)
            
            if [[ $file_count -gt 0 ]]; then
                results="suites_0_name=bats_tests"
                results="${results}"$'\n'"suites_0_framework=bats"
                results="${results}"$'\n'"suites_0_test_files_count=${file_count}"
                suites_count=1
            fi
        fi
    fi

    # Output results
    echo "suites_count=${suites_count}"
    if [[ -n "$results" ]]; then
        echo "$results"
    fi

    return 0
}

# Detect build requirements for BATS projects
# Usage: detect_build_requirements <project_root> <framework_metadata>
# Returns: Build requirements as flat data
detect_build_requirements() {
    local project_root="$1"
    local framework_metadata="$2"

    # BATS projects typically don't require building (scripts are interpreted)
    echo "requires_build=false"
    echo "build_steps_count=0"
    echo "build_commands_count=0"
    echo "build_dependencies_count=0"
    echo "build_artifacts_count=0"
    return 0
}

# Get build steps for containerized build
# Usage: get_build_steps <project_root> <build_requirements>
# Returns: Build steps as flat data
get_build_steps() {
    local project_root="$1"
    local build_requirements="$2"

    # Stub implementation (no build steps needed for BATS)
    echo "build_steps_count=0"
    return 0
}

# Execute test suite using BATS test runner
# Usage: execute_test_suite <test_suite> <test_image> <execution_config>
# Returns: Execution result as flat data
# Behavior: Executes bats command in container
execute_test_suite() {
    local test_suite="$1"
    local test_image="$2"
    local execution_config="$3"

    # Stub implementation (will be expanded in later phases)
    # For now, return basic structure
    echo "exit_code=0"
    echo "duration=0.0"
    echo "execution_method=docker"
    echo "test_command=bats"
    return 0
}

# Parse test results from BATS test output
# Usage: parse_test_results <output> <exit_code>
# Returns: Parsed results as flat data
# Behavior: Parses bats test output to extract test counts and status
parse_test_results() {
    local output="$1"
    local exit_code="$2"

    # Stub implementation (will be expanded in later phases)
    # For now, return basic structure based on exit code
    if [[ "$exit_code" == "0" ]]; then
        echo "total_tests=0"
        echo "passed_tests=0"
        echo "failed_tests=0"
        echo "skipped_tests=0"
        echo "test_details_count=0"
        echo "status=passed"
    else
        echo "total_tests=0"
        echo "passed_tests=0"
        echo "failed_tests=0"
        echo "skipped_tests=0"
        echo "test_details_count=0"
        echo "status=failed"
    fi

    return 0
}

# Get module metadata
# Usage: get_metadata
# Returns: Module metadata as flat data
get_metadata() {
    echo "module_type=framework"
    echo "language=bash"
    echo "frameworks_0=bats"
    echo "frameworks_count=1"
    echo "project_type=shell_script"
    echo "version=0.1.0"
    echo "capabilities_0=testing"
    echo "capabilities_count=1"
    echo "required_binaries_0=bats"
    echo "required_binaries_count=1"
    return 0
}


# End of: mod/frameworks/bats/mod.sh

# Included from: mod/frameworks/cargo/mod.sh
#!/usr/bin/env bash

# Suitey Cargo Framework Module
# Handles Cargo framework for Rust language
# Provides framework-specific test discovery, execution, and parsing for Cargo projects
#
# This module works in conjunction with the Rust language module:
# - Language module (mod/languages/rust/mod.sh) detects Rust language presence
# - Framework module (this module) handles Cargo-specific operations
# - Framework module has higher priority than language module for framework-specific operations

# Detect if Cargo project is present (framework-level detection)
# Usage: detect <project_root>
# Returns: Detection result as flat data
# Behavior: Checks for Cargo.toml (framework-specific indicator)
detect() {
    local project_root="$1"

    # Validate input
    if [[ -z "$project_root" ]] || [[ ! -d "$project_root" ]]; then
        echo "detected=false"
        echo "confidence=low"
        echo "indicators_count=0"
        echo "language=rust"
        echo "frameworks_0=cargo"
        return 0
    fi

    # Check for Cargo.toml file (primary Cargo indicator)
    if [[ -f "$project_root/Cargo.toml" ]]; then
        echo "detected=true"
        echo "confidence=high"
        echo "indicators_0=Cargo.toml"
        echo "indicators_count=1"
        echo "language=rust"
        echo "frameworks_0=cargo"
        return 0
    fi

    # Not detected
    echo "detected=false"
    echo "confidence=low"
    echo "indicators_count=0"
    echo "language=rust"
    echo "frameworks_0=cargo"
    return 0
}

# Check if required binaries are available
# Usage: check_binaries <project_root>
# Returns: Binary status as flat data
# Behavior: Checks for cargo binary in PATH and reports version if available
check_binaries() {
    local project_root="$1"

    # Check for cargo binary in PATH
    if command -v cargo >/dev/null 2>&1; then
        local cargo_version
        cargo_version=$(cargo --version 2>/dev/null | head -1 || echo "unknown")
        # Remove "cargo " prefix if present
        cargo_version="${cargo_version#cargo }"
        echo "available=true"
        echo "binaries_0=cargo"
        echo "binaries_count=1"
        echo "versions_cargo=$cargo_version"
        echo "container_check=false"
    else
        echo "available=false"
        echo "binaries_0=cargo"
        echo "binaries_count=1"
        echo "container_check=false"
    fi

    return 0
}

# Discover test suites in the project using Cargo-specific patterns
# Usage: discover_test_suites <project_root> <framework_metadata>
# Returns: Test suites as flat data
# Behavior: Finds unit tests in src/ and integration tests in tests/ directory
discover_test_suites() {
    local project_root="$1"
    local framework_metadata="$2"

    # Validate input
    if [[ -z "$project_root" ]] || [[ ! -d "$project_root" ]]; then
        echo "suites_count=0"
        return 0
    fi

    local suites_count=0
    local suite_index=0
    local results=""

    # Discover unit tests in src/ directory
    # Cargo unit tests are in files with #[cfg(test)] modules
    if [[ -d "$project_root/src" ]]; then
        local unit_test_files
        unit_test_files=$(find "$project_root/src" -name "*.rs" -type f 2>/dev/null | head -5)
        
        if [[ -n "$unit_test_files" ]]; then
            # Count files with test modules (simplified - just check if file exists)
            local unit_file_count
            unit_file_count=$(echo "$unit_test_files" | wc -l)
            
            if [[ $unit_file_count -gt 0 ]]; then
                if [[ -z "$results" ]]; then
                    results="suites_${suite_index}_name=unit_tests"
                else
                    results="${results}"$'\n'"suites_${suite_index}_name=unit_tests"
                fi
                results="${results}"$'\n'"suites_${suite_index}_framework=cargo"
                results="${results}"$'\n'"suites_${suite_index}_test_files_count=${unit_file_count}"
                
                suites_count=$((suites_count + 1))
                suite_index=$((suite_index + 1))
            fi
        fi
    fi

    # Discover integration tests in tests/ directory
    if [[ -d "$project_root/tests" ]]; then
        local integration_test_files
        integration_test_files=$(find "$project_root/tests" -name "*.rs" -type f 2>/dev/null)
        
        if [[ -n "$integration_test_files" ]]; then
            local integration_file_count
            integration_file_count=$(echo "$integration_test_files" | wc -l)
            
            if [[ $integration_file_count -gt 0 ]]; then
                if [[ -z "$results" ]]; then
                    results="suites_${suite_index}_name=integration_tests"
                else
                    results="${results}"$'\n'"suites_${suite_index}_name=integration_tests"
                fi
                results="${results}"$'\n'"suites_${suite_index}_framework=cargo"
                results="${results}"$'\n'"suites_${suite_index}_test_files_count=${integration_file_count}"
                
                suites_count=$((suites_count + 1))
            fi
        fi
    fi

    # Output results
    echo "suites_count=${suites_count}"
    if [[ -n "$results" ]]; then
        echo "$results"
    fi

    return 0
}

# Detect build requirements for Cargo projects
# Usage: detect_build_requirements <project_root> <framework_metadata>
# Returns: Build requirements as flat data
detect_build_requirements() {
    local project_root="$1"
    local framework_metadata="$2"

    # Cargo projects require building before testing
    echo "requires_build=true"
    echo "build_steps_count=1"
    echo "build_commands_0=cargo build --tests"
    echo "build_commands_count=1"
    echo "build_dependencies_count=0"
    echo "build_artifacts_count=0"
    return 0
}

# Get build steps for containerized build
# Usage: get_build_steps <project_root> <build_requirements>
# Returns: Build steps as flat data
get_build_steps() {
    local project_root="$1"
    local build_requirements="$2"

    # Stub implementation (will be expanded in later phases)
    echo "build_steps_count=0"
    return 0
}

# Execute test suite using Cargo test runner
# Usage: execute_test_suite <test_suite> <test_image> <execution_config>
# Returns: Execution result as flat data
# Behavior: Executes cargo test command in container
execute_test_suite() {
    local test_suite="$1"
    local test_image="$2"
    local execution_config="$3"

    # Stub implementation (will be expanded in later phases)
    # For now, return basic structure
    echo "exit_code=0"
    echo "duration=0.0"
    echo "execution_method=docker"
    echo "test_command=cargo test"
    return 0
}

# Parse test results from Cargo test output
# Usage: parse_test_results <output> <exit_code>
# Returns: Parsed results as flat data
# Behavior: Parses cargo test output to extract test counts and status
parse_test_results() {
    local output="$1"
    local exit_code="$2"

    # Stub implementation (will be expanded in later phases)
    # For now, return basic structure based on exit code
    if [[ "$exit_code" == "0" ]]; then
        echo "total_tests=0"
        echo "passed_tests=0"
        echo "failed_tests=0"
        echo "skipped_tests=0"
        echo "test_details_count=0"
        echo "status=passed"
    else
        echo "total_tests=0"
        echo "passed_tests=0"
        echo "failed_tests=0"
        echo "skipped_tests=0"
        echo "test_details_count=0"
        echo "status=failed"
    fi

    return 0
}

# Get module metadata
# Usage: get_metadata
# Returns: Module metadata as flat data
get_metadata() {
    echo "module_type=framework"
    echo "language=rust"
    echo "frameworks_0=cargo"
    echo "frameworks_count=1"
    echo "project_type=cargo_project"
    echo "version=0.1.0"
    echo "capabilities_0=testing"
    echo "capabilities_1=compilation"
    echo "capabilities_count=2"
    echo "required_binaries_0=cargo"
    echo "required_binaries_count=1"
    return 0
}


# End of: mod/frameworks/cargo/mod.sh

# Included from: mod/languages/bash/mod.sh
#!/usr/bin/env bash

# Suitey Bash Module
# Handles Bash language with BATS framework
# Provides detection, test discovery, build detection, and execution for Bash projects

# Detect if Bash/BATS project is present
# Usage: detect <project_root>
# Returns: Detection result as flat data
# Behavior: Checks for .bats files (high confidence), test directories (medium), or .sh files (low)
detect() {
    local project_root="$1"

    # Validate input
    if [[ -z "$project_root" ]] || [[ ! -d "$project_root" ]]; then
        echo "detected=false"
        echo "confidence=low"
        echo "indicators_count=0"
        echo "language=bash"
        echo "frameworks_0=bats"
        return 0
    fi

    # Check for .bats files (primary indicator - highest confidence)
    # Look in common test directories: tests/bats/, test/bats/, tests/, test/
    local bats_files
    bats_files=$(find "$project_root" -maxdepth 3 -name "*.bats" -type f 2>/dev/null | head -1)
    if [[ -n "$bats_files" ]]; then
        echo "detected=true"
        echo "confidence=high"
        echo "indicators_0=bats_test_files"
        echo "indicators_count=1"
        echo "language=bash"
        echo "frameworks_0=bats"
        return 0
    fi

    # Check for BATS test directory structure (secondary indicator - medium confidence)
    if [[ -d "$project_root/tests/bats" ]] || [[ -d "$project_root/test/bats" ]]; then
        echo "detected=true"
        echo "confidence=medium"
        echo "indicators_0=bats_test_directory"
        echo "indicators_count=1"
        echo "language=bash"
        echo "frameworks_0=bats"
        return 0
    fi

    # Check for .sh files with bash shebang (weak indicator - low confidence)
    # Only check in top-level directories to avoid false positives
    local sh_files
    sh_files=$(find "$project_root" -maxdepth 2 -name "*.sh" -type f 2>/dev/null | head -1)
    if [[ -n "$sh_files" ]]; then
        # Check if file has bash shebang
        if head -1 "$sh_files" 2>/dev/null | grep -q "#!/usr/bin/env bash\|#!/bin/bash"; then
            echo "detected=true"
            echo "confidence=low"
            echo "indicators_0=bash_script_files"
            echo "indicators_count=1"
            echo "language=bash"
            echo "frameworks_0=bats"
            return 0
        fi
    fi

    # Not detected
    echo "detected=false"
    echo "confidence=low"
    echo "indicators_count=0"
    echo "language=bash"
    echo "frameworks_0=bats"
    return 0
}

# Check if required binaries are available
# Usage: check_binaries <project_root>
# Returns: Binary status as flat data
# Behavior: Checks for bats binary in PATH and reports version if available
check_binaries() {
    local project_root="$1"

    # Check for bats binary in PATH
    if command -v bats >/dev/null 2>&1; then
        local bats_version
        bats_version=$(bats --version 2>/dev/null | head -1 || echo "unknown")
        # Remove "bats " prefix if present
        bats_version="${bats_version#bats }"
        echo "available=true"
        echo "binaries_0=bats"
        echo "binaries_count=1"
        echo "versions_bats=$bats_version"
        echo "container_check=false"
    else
        echo "available=false"
        echo "binaries_0=bats"
        echo "binaries_count=1"
        echo "container_check=false"
    fi

    return 0
}

# Discover test suites in the project
# Usage: discover_test_suites <project_root> <framework_metadata>
# Returns: Test suites as flat data
discover_test_suites() {
    local project_root="$1"
    local framework_metadata="$2"

    # BATS tests are typically in tests/bats/ or test/bats/ directories
    # For now, return empty (stub implementation)
    echo "suites_count=0"
    return 0
}

# Detect build requirements
# Usage: detect_build_requirements <project_root> <framework_metadata>
# Returns: Build requirements as flat data
detect_build_requirements() {
    local project_root="$1"
    local framework_metadata="$2"

    # Bash projects typically don't require building (scripts are interpreted)
    echo "requires_build=false"
    echo "build_steps_count=0"
    echo "build_commands_count=0"
    echo "build_dependencies_count=0"
    echo "build_artifacts_count=0"
    return 0
}

# Get build steps for containerized build
# Usage: get_build_steps <project_root> <build_requirements>
# Returns: Build steps as flat data
get_build_steps() {
    local project_root="$1"
    local build_requirements="$2"

    # Stub implementation (no build steps needed for Bash)
    echo "build_steps_count=0"
    return 0
}

# Execute test suite
# Usage: execute_test_suite <test_suite> <test_image> <execution_config>
# Returns: Execution result as flat data
execute_test_suite() {
    local test_suite="$1"
    local test_image="$2"
    local execution_config="$3"

    # Stub implementation
    echo "exit_code=0"
    echo "duration=0.0"
    echo "execution_method=docker"
    return 0
}

# Parse test results from framework output
# Usage: parse_test_results <output> <exit_code>
# Returns: Parsed results as flat data
parse_test_results() {
    local output="$1"
    local exit_code="$2"

    # Stub implementation
    echo "total_tests=0"
    echo "passed_tests=0"
    echo "failed_tests=0"
    echo "skipped_tests=0"
    echo "test_details_count=0"
    echo "status=passed"
    return 0
}

# Get module metadata
# Usage: get_metadata
# Returns: Module metadata as flat data
get_metadata() {
    echo "module_type=language"
    echo "language=bash"
    echo "frameworks_0=bats"
    echo "frameworks_count=1"
    echo "project_type=shell_script"
    echo "version=0.1.0"
    echo "capabilities_0=testing"
    echo "capabilities_count=1"
    echo "required_binaries_0=bats"
    echo "required_binaries_count=1"
    return 0
}


# End of: mod/languages/bash/mod.sh

# Included from: mod/languages/rust/mod.sh
#!/usr/bin/env bash

# Suitey Rust Module
# Handles Rust language with Cargo framework
# Provides detection, test discovery, build detection, and execution for Rust projects

# Detect if Rust/Cargo project is present
# Usage: detect <project_root>
# Returns: Detection result as flat data
# Behavior: Checks for Cargo.toml (high confidence), Cargo.lock (medium), or .rs files (low)
detect() {
    local project_root="$1"

    # Validate input
    if [[ -z "$project_root" ]] || [[ ! -d "$project_root" ]]; then
        echo "detected=false"
        echo "confidence=low"
        echo "indicators_count=0"
        echo "language=rust"
        echo "frameworks_0=cargo"
        return 0
    fi

    # Check for Cargo.toml file (primary indicator - highest confidence)
    if [[ -f "$project_root/Cargo.toml" ]]; then
        echo "detected=true"
        echo "confidence=high"
        echo "indicators_0=Cargo.toml"
        echo "indicators_count=1"
        echo "language=rust"
        echo "frameworks_0=cargo"
        return 0
    fi

    # Check for Cargo.lock (secondary indicator - medium confidence)
    if [[ -f "$project_root/Cargo.lock" ]]; then
        echo "detected=true"
        echo "confidence=medium"
        echo "indicators_0=Cargo.lock"
        echo "indicators_count=1"
        echo "language=rust"
        echo "frameworks_0=cargo"
        return 0
    fi

    # Check for .rs files (weak indicator - low confidence)
    # Only check in top-level directories to avoid false positives
    if find "$project_root" -maxdepth 2 -name "*.rs" -type f 2>/dev/null | head -1 | grep -q .; then
        echo "detected=true"
        echo "confidence=low"
        echo "indicators_0=rust_source_files"
        echo "indicators_count=1"
        echo "language=rust"
        echo "frameworks_0=cargo"
        return 0
    fi

    # Not detected
    echo "detected=false"
    echo "confidence=low"
    echo "indicators_count=0"
    echo "language=rust"
    echo "frameworks_0=cargo"
    return 0
}

# Check if required binaries are available
# Usage: check_binaries <project_root>
# Returns: Binary status as flat data
# Behavior: Checks for cargo binary in PATH and reports version if available
check_binaries() {
    local project_root="$1"

    # Check for cargo binary in PATH
    if command -v cargo >/dev/null 2>&1; then
        local cargo_version
        cargo_version=$(cargo --version 2>/dev/null | head -1 || echo "unknown")
        # Remove "cargo " prefix if present
        cargo_version="${cargo_version#cargo }"
        echo "available=true"
        echo "binaries_0=cargo"
        echo "binaries_count=1"
        echo "versions_cargo=$cargo_version"
        echo "container_check=false"
    else
        echo "available=false"
        echo "binaries_0=cargo"
        echo "binaries_count=1"
        echo "container_check=false"
    fi

    return 0
}

# Discover test suites in the project
# Usage: discover_test_suites <project_root> <framework_metadata>
# Returns: Test suites as flat data
discover_test_suites() {
    local project_root="$1"
    local framework_metadata="$2"

    # Cargo tests are typically in src/ or tests/ directories
    # For now, return empty (stub implementation)
    echo "suites_count=0"
    return 0
}

# Detect build requirements
# Usage: detect_build_requirements <project_root> <framework_metadata>
# Returns: Build requirements as flat data
detect_build_requirements() {
    local project_root="$1"
    local framework_metadata="$2"

    # Rust projects typically require building before testing
    echo "requires_build=true"
    echo "build_steps_count=1"
    echo "build_commands_0=cargo build --tests"
    echo "build_commands_count=1"
    echo "build_dependencies_count=0"
    echo "build_artifacts_count=0"
    return 0
}

# Get build steps for containerized build
# Usage: get_build_steps <project_root> <build_requirements>
# Returns: Build steps as flat data
get_build_steps() {
    local project_root="$1"
    local build_requirements="$2"

    # Stub implementation
    echo "build_steps_count=0"
    return 0
}

# Execute test suite
# Usage: execute_test_suite <test_suite> <test_image> <execution_config>
# Returns: Execution result as flat data
execute_test_suite() {
    local test_suite="$1"
    local test_image="$2"
    local execution_config="$3"

    # Stub implementation
    echo "exit_code=0"
    echo "duration=0.0"
    echo "execution_method=docker"
    return 0
}

# Parse test results from framework output
# Usage: parse_test_results <output> <exit_code>
# Returns: Parsed results as flat data
parse_test_results() {
    local output="$1"
    local exit_code="$2"

    # Stub implementation
    echo "total_tests=0"
    echo "passed_tests=0"
    echo "failed_tests=0"
    echo "skipped_tests=0"
    echo "test_details_count=0"
    echo "status=passed"
    return 0
}

# Get module metadata
# Usage: get_metadata
# Returns: Module metadata as flat data
get_metadata() {
    echo "module_type=language"
    echo "language=rust"
    echo "frameworks_0=cargo"
    echo "frameworks_count=1"
    echo "project_type=cargo"
    echo "version=0.1.0"
    echo "capabilities_0=testing"
    echo "capabilities_1=compilation"
    echo "capabilities_count=2"
    echo "required_binaries_0=cargo"
    echo "required_binaries_count=1"
    return 0
}


# End of: mod/languages/rust/mod.sh

# Main Suitey functionality will be added here

# Exit code constants
# 0 = success
# 1 = tests failed (for future use)
# 2 = suitey error (invalid arguments, internal errors, etc.)
readonly EXIT_SUCCESS=0
readonly EXIT_TESTS_FAILED=1
readonly EXIT_SUITEY_ERROR=2

show_help() {
    cat << 'HELP_EOF'
Suitey v0.1.0 - Cross-platform test runner

Usage: suitey.sh [OPTIONS] [COMMAND]

DESCRIPTION
    Suitey is a cross-platform test runner that automatically detects test suites,
    builds projects, and executes tests in isolated Docker containers.

OPTIONS
    -h, --help          Show this help message and exit
    -v, --version       Show version information and exit

COMMANDS
    (Commands will be implemented in future phases)

EXAMPLES
    suitey.sh --help          Show help information
    suitey.sh --version       Show version information
    suitey.sh                 Show help (default behavior)

For more information, see the Suitey documentation.
HELP_EOF
}

show_version() {
    echo "Suitey v0.1.0"
    echo "Build system functional - ready for implementation"
}

# Run all environment validation checks
# Returns 0 if all checks pass, 1 if any check fails
run_environment_checks() {
    local check_failed=0

    # Run all environment checks
    if ! check_bash_version; then
        check_failed=1
    fi

    if ! check_docker_installed; then
        check_failed=1
    fi

    if ! check_docker_daemon_running; then
        check_failed=1
    fi

    if ! check_tmp_writable; then
        check_failed=1
    fi

    # Return failure if any check failed
    if [[ $check_failed -eq 1 ]]; then
        return 1
    fi

    return 0
}

# Validate and normalize directory path
# Returns normalized absolute path on success, exits with error on failure
validate_directory() {
    local dir_path="$1"
    local original_path="$1"
    
    # Check if directory exists first (before normalization)
    if [[ ! -e "$dir_path" ]]; then
        echo "Error: Directory does not exist: $original_path" >&2
        echo "Run '$0 --help' for usage information." >&2
        return 1
    fi
    
    # Check if it's actually a directory (not a file)
    if [[ ! -d "$dir_path" ]]; then
        echo "Error: Path is not a directory: $original_path" >&2
        echo "Run '$0 --help' for usage information." >&2
        return 1
    fi
    
    # Normalize path: resolve to absolute path
    # Use cd to resolve symlinks and normalize . and ..
    local normalized_path
    if normalized_path="$(cd "$dir_path" 2>/dev/null && pwd)"; then
        dir_path="$normalized_path"
    else
        # If cd failed, try to construct absolute path
        if [[ "$dir_path" != /* ]]; then
            # Relative path - make absolute
            dir_path="$(pwd)/$dir_path"
        fi
    fi
    
    # Check if directory is readable
    if [[ ! -r "$dir_path" ]]; then
        echo "Error: Directory is not readable: $original_path" >&2
        echo "Run '$0 --help' for usage information." >&2
        return 1
    fi
    
    # Return normalized absolute path
    echo "$dir_path"
    return 0
}

main() {
    local target_directory=""
    
    # Parse command-line arguments
    # Options take precedence over directory arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -v|--version)
                show_version
                exit $EXIT_SUCCESS
                ;;
            -*)
                # Unknown option
                echo "Error: Unknown option '$1'" >&2
                echo "Run '$0 --help' for usage information." >&2
                exit $EXIT_SUITEY_ERROR
                ;;
            *)
                # Non-option argument - treat as directory
                if [[ -n "$target_directory" ]]; then
                    echo "Error: Multiple directory arguments provided. Please specify only one directory." >&2
                    echo "Run '$0 --help' for usage information." >&2
                    exit $EXIT_SUITEY_ERROR
                fi
                target_directory="$1"
                ;;
        esac
        shift
    done
    
    # If no arguments provided, show help
    if [[ -z "$target_directory" ]]; then
        show_help
        exit $EXIT_SUCCESS
    fi
    
    # Validate directory
    local normalized_dir
    normalized_dir=$(validate_directory "$target_directory")
    if [[ $? -ne 0 ]]; then
        exit $EXIT_SUITEY_ERROR
    fi
    
    # Run environment checks before execution
    if ! run_environment_checks; then
        echo "" >&2
        echo "Environment validation failed. Please fix the issues above and try again." >&2
        exit $EXIT_SUITEY_ERROR
    fi
    
    # Store directory for future workflow execution
    # For now, we accept the directory and show a placeholder message
    # In future phases, this will trigger the full workflow
    echo "Suitey v0.1.0"
    echo "Target directory: $normalized_dir"
    echo ""
    echo "Workflow execution will be implemented in future phases."
    echo "Directory validated and ready for processing."
    exit $EXIT_SUCCESS
}

# Run main function
main "$@"
